// Copyright 2018 Intel Corporation.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"
)

func main() {
	type step struct {
		name string
		fn   func() error
	}

	var c collector

	steps := []step{
		{"init collector", c.init},
		{"locate test dir", c.locateTestDir},
		{"read extensions", c.readExtensions},
		{"parse command-line args", c.parseFlags},
		{"validate command-line args", c.validateFlags},
		{"check perf tool", c.checkPerfTool},
		{"prepare work dir", c.prepareWorkDir},
		{"visit work dir", c.visitWorkDir},
		{"collect counters", c.collectCounters},
		{"print csv", c.printCSV},
	}

	for _, s := range steps {
		if err := s.fn(); err != nil {
			log.Fatalf("%s: %v", s.name, err)
		}
	}
}

type collector struct {
	// memArgRE matches any kind of memory operand.
	// Displacement and indexing expressions are optional.
	memArgRE *regexp.Regexp

	// vmemArgRE is almost like memArgRE, but indexing expression is mandatory
	// and index register must be one of the X/Y/Z.
	vmemArgRE *regexp.Regexp

	// testDir is AVX-512 encoder end2end test suite path.
	testDir string

	// availableExt is a set of available testfiles for evaluation.
	availableExt map[string]bool

	// stats is a combined list of collected statistics.
	stats []*iformStats

	// current holds evaluation state which is valid only
	// during single extension evaluation stage.
	current struct {
		extension string
		scanner   testFileScanner
	}

	// Fields below are initialized by command-line arguments (flags).

	extensions    []string
	perfTool      string
	workDir       string
	iformSpanSize uint
	loopCount     uint
	perfRounds    uint
}

func (c *collector) init() error {
	c.memArgRE = regexp.MustCompile(`(?:-?\d+)?\(\w+\)(?:\(\w+\*[1248]\))?`)
	c.vmemArgRE = regexp.MustCompile(`(?:-?\d+)?\(\w+\)\(([XYZ])\d+\*[1248]\)`)
	c.availableExt = make(map[string]bool)
	return nil
}

func (c *collector) locateTestDir() error {
	goroot := runtime.GOROOT()
	// The AVX-512 encoder end2end test suite path is unlikely to change.
	// If it ever does, this should be updated.
	c.testDir = filepath.Join(goroot,
		"src", "cmd", "asm", "internal", "asm", "testdata", "avx512enc")
	if !fileExists(c.testDir) {
		return fmt.Errorf("can't locate AVX-512 testdata: %s doesn't exist", c.testDir)
	}
	return nil
}

func (c *collector) readExtensions() error {
	files, err := ioutil.ReadDir(c.testDir)
	if err != nil {
		return err
	}

	for _, f := range files {
		ext := strings.TrimSuffix(f.Name(), ".s")
		c.availableExt[ext] = true
	}

	return nil
}

func (c *collector) parseFlags() error {
	extensions := flag.String("extensions", "avx512f,avx512dq,avx512cd,avx512bw",
		`comma-separated list of extensions to be evaluated`)
	flag.StringVar(&c.perfTool, "perf", "perf",
		`perf tool binary name. ocperf and other drop-in replacements will do`)
	flag.StringVar(&c.workDir, "workDir", "./avx512counters-workdir",
		`where to put results and the intermediate files`)
	flag.UintVar(&c.iformSpanSize, "iformSpanSize", 100,
		`how many instruction lines form a single iform span. Higher values slow down the collection`)
	flag.UintVar(&c.loopCount, "loopCount", 1*1000*1000,
		`how many times to execute every iform span. Higher values slow down the collection`)
	flag.UintVar(&c.perfRounds, "perfRounds", 1,
		`how many times to re-validate perf results. Higher values slow down the collection`)

	flag.Parse()

	for _, ext := range strings.Split(*extensions, ",") {
		ext = strings.TrimSpace(ext)
		c.extensions = append(c.extensions, ext)
	}

	absWorkDir, err := filepath.Abs(c.workDir)
	if err != nil {
		return fmt.Errorf("expand -workDir: %v", err)
	}
	c.workDir = absWorkDir
	return nil
}

func (c *collector) validateFlags() error {
	for _, ext := range c.extensions {
		if !c.availableExt[ext] {
			return fmt.Errorf("unavailable extension: %q", ext)
		}
	}

	switch {
	case len(c.extensions) == 0:
		return errors.New("expected at least 1 extension name")
	case c.perfTool == "":
		return errors.New("argument -perf can't be empty")
	case c.iformSpanSize == 0:
		return errors.New("argument -iformSpanSize can't be 0")
	case c.loopCount == 0:
		return errors.New("argument -loopCount can't be 0")
	case c.perfRounds == 0:
		return errors.New("argument -perfRounds can't be 0")
	default:
		return nil
	}
}

func (c *collector) checkPerfTool() error {
	_, err := c.runPerf("echo")
	return err
}

func (c *collector) prepareWorkDir() error {
	if !fileExists(c.workDir) {
		if err := os.Mkdir(c.workDir, 0700); err != nil {
			return err
		}
	}

	// Always overwrite the main file, just in case.
	mainFile := filepath.Join(c.workDir, "main.go")
	mainFileContents := fmt.Sprintf(`
		// Code generated by avx512counters. DO NOT EDIT.
		package main
		func avx512routine(*[1024]byte)
		func main() {
			var memory [1024]byte
			for i := 0; i < %d; i++ {
				// Fill memory argument with some values.
				for i := range memory {
					memory[i] = byte(i)
				}
				avx512routine(&memory)
			}
		}`, c.loopCount)
	return ioutil.WriteFile(mainFile, []byte(mainFileContents), 0666)
}

func (c *collector) visitWorkDir() error {
	return os.Chdir(c.workDir)
}

func (c *collector) collectCounters() error {
	for _, ext := range c.extensions {
		filename := filepath.Join(c.testDir, ext+".s")
		c.current.extension = ext
		c.current.scanner = testFileScanner{}
		if err := c.current.scanner.init(filename); err != nil {
			log.Printf("skip %s: can't scan test file: %v", ext, err)
			continue
		}

		stats, err := c.evaluateCurrent()
		if err != nil {
			log.Printf("failed %s: %v", ext, err)
			continue
		}

		c.stats = append(c.stats, stats...)
	}

	return nil
}

func (c *collector) evaluateCurrent() ([]*iformStats, error) {
	// maps instruction form to a list of available samples.
	testMap := make(map[string][]string)

	for c.current.scanner.scan() {
		l := c.current.scanner.line
		iform := instructionForm(l)
		testMap[iform] = append(testMap[iform], l.text)
	}

	stats := make([]*iformStats, 0, len(testMap))
	for iform, lines := range testMap {
		asmText := c.generateAsmText(lines)
		istats, err := c.evaluateIform(iform, asmText)
		if err != nil {
			log.Printf("%s: skip %s: %v", c.current.extension, iform, err)
		} else {
			istats.ext = c.current.extension
			stats = append(stats, istats)
			log.Printf("%s: collected %s", c.current.extension, iform)
		}
	}

	return stats, c.current.scanner.err
}

// generateAsmText returns asm file text that contains avx512routine function
// definition which is supposed to be called from evaluating loop.
func (c *collector) generateAsmText(asmLines []string) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by avx512counters. DO NOT EDIT.\n")
	buf.WriteString("TEXT Â·avx512routine(SB), 0, $0\n")
	buf.WriteString("\tMOVQ memory+0(FP), R12\n")
	for samples := uint(0); samples < c.iformSpanSize; samples++ {
		for _, line := range asmLines {
			// Replace all memory operands with "(R12)".
			if c.vmemArgRE.MatchString(line) {
				// Can't replace vsib memory operand with just (R12).
				// We use X10/Y10/Z10 registers as they are never written to.
				line = c.vmemArgRE.ReplaceAllString(line, "(R12)(${1}10*1)")
			} else {
				line = c.memArgRE.ReplaceAllString(line, "(R12)")
			}
			buf.WriteString(line + "\n")
			samples++
		}
	}
	buf.WriteString("\tRET\n")
	return buf.Bytes()

}

func (c *collector) evaluateIform(iform string, asmText []byte) (*iformStats, error) {
	err := ioutil.WriteFile(filepath.Join(c.workDir, "avx512routine_amd64.s"), asmText, 0666)
	if err != nil {
		return nil, err
	}
	if err := buildAVX512routine(); err != nil {
		return nil, err
	}

	// Make sure we had enough time to make it out of turbo2.
	// (Even though build time should make it safe to continue.)
	time.Sleep(100 * time.Millisecond)

	// We can't rely on perf stats being 100% precise and stable
	// even with high repetition numbers.
	// To reduce error probability significantly, perf
	// is executed multiple times and worst result is reported.
	var worst iformStats
	for i := uint(0); i < c.perfRounds; i++ {
		out, err := c.runPerf("./avx512routine")
		if err != nil {
			return nil, err
		}

		istats := decodeIformStats(iform, out)

		// If it's already touched level2, return without additional rounds.
		if istats.level2 != 0 {
			return &istats, nil
		}
		if worst.level1 <= istats.level1 && worst.level0 <= istats.level0 {
			worst = istats
		}
		time.Sleep(10 * time.Millisecond)
	}

	return &worst, nil
}

func (c *collector) runPerf(program string) (string, error) {
	out, err := exec.Command(c.perfTool, "stat", "-x,",
		"-e", "core_power.lvl0_turbo_license",
		"-e", "core_power.lvl1_turbo_license",
		"-e", "core_power.lvl2_turbo_license",
		program).CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("%v: %s", err, out)
	}
	return string(out), nil
}

func (c *collector) printCSV() error {
	sort.SliceStable(c.stats, func(i, j int) bool {
		return c.stats[i].iform < c.stats[j].iform
	})

	// Print header.
	fmt.Println(`"extension","instruction form","class","level0","level1","level2"`)

	// Print rows.
	for _, istats := range c.stats {
		class := "turbo0"
		switch {
		case istats.level2 > 0:
			class = "turbo2"
		case istats.level1 > 0:
			class = "turbo1"
		}
		fmt.Printf(`"%s","%s","%s","%d","%d","%d"`+"\n",
			istats.ext, istats.iform, class,
			istats.level0, istats.level1, istats.level2)
	}

	return nil
}

// iformStats is parsed perf output for particular instruction forme evaluation.
type iformStats struct {
	ext   string // extension instruction belongs to
	iform string // tested instruction form

	level0 int64 // turbo0 event counter
	level1 int64 // turbo1 event counter
	level2 int64 // turbo2 event counter
}

// testLine is decoded end2end test file line.
// Represents single instruction.
type testLine struct {
	op   string   // Opcode
	args []string // Instruction arguments
	text string   // Asm text (whole line)
}

// testFileScanner reads Go asm end2end test file into testLine objects.
type testFileScanner struct {
	filename string
	lineRE   *regexp.Regexp
	lines    []string // Unprocessed lines
	line     testLine // Last decoded line
	err      error
}

func (s *testFileScanner) init(filename string) error {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return err
	}
	s.lineRE = regexp.MustCompile(`\t(.*?) (.*?) // [0-9a-f]+`)
	s.lines = strings.Split(string(data), "\n")
	// Instructions lines start with "\t".
	// Skip everything before them.
	for len(s.lines[0]) == 0 || s.lines[0][0] != '\t' {
		s.lines = s.lines[1:]
	}
	return nil
}

func (s *testFileScanner) scan() bool {
	if s.err != nil {
		return false
	}
	if len(s.lines) == 0 {
		s.err = fmt.Errorf("%s: unexpected EOF (expected RET instruction)", s.filename)
		return false
	}
	if s.lines[0] == "\tRET" {
		return false
	}
	m := s.lineRE.FindStringSubmatch(s.lines[0])
	if m == nil {
		s.err = fmt.Errorf("%s: unexpected %q line (does not match pattern)", s.filename, s.lines[0])
		return false
	}
	s.lines = s.lines[1:]
	var args []string
	for _, x := range strings.Split(m[2], ",") {
		args = append(args, strings.TrimSpace(x))
	}
	s.line = testLine{op: m[1], args: args, text: m[0]}
	return true
}

// argumentClass returns parameter type of given argument value.
//
// For example:
//	"$1" argument has type of "imm" (immediate constant),
//	"K2" is "K" (opmask register).
func argumentClass(arg string) string {
	switch arg[0] {
	case '$':
		return "imm"
	case 'K':
		return "K"
	case 'X':
		return "X"
	case 'Y':
		return "Y"
	case 'Z':
		return "Z"
	default:
		if strings.Contains(arg, "(") && strings.Contains(arg, ")") {
			return "mem"
		}
		return "reg"
	}
}

func instructionForm(l testLine) string {
	if len(l.args) == 0 {
		return l.op
	}

	var argClasses []string
	for _, arg := range l.args {
		argClasses = append(argClasses, argumentClass(arg))
	}
	return l.op + " " + strings.Join(argClasses, ", ")
}

func buildAVX512routine() error {
	out, err := exec.Command("go", "build", "-o", "avx512routine", ".").CombinedOutput()
	if err != nil {
		return fmt.Errorf("build failed: %v: %s", err, out)
	}
	return nil
}

func decodeIformStats(iform, perfOut string) iformStats {
	atoi := func(s string) int64 {
		v, err := strconv.ParseInt(s, 10, 64)
		if err != nil {
			return 0
		}
		return v
	}
	fetchInt64 := func(line string) int64 {
		return atoi(strings.Split(line, ",")[0])
	}

	lines := strings.Split(perfOut, "\n")
	return iformStats{
		iform:  iform,
		level0: fetchInt64(lines[0]),
		level1: fetchInt64(lines[1]),
		level2: fetchInt64(lines[2]),
	}
}

// fileExists reports whether file with given name exists.
func fileExists(name string) bool {
	_, err := os.Stat(name)
	return !os.IsNotExist(err)
}
